---
title: "FinalReport"
format: html
---

Below is reproducible code to produce all the figures we use for our Analysis part of our Final Project.

```{r}
library(dplyr)
library(psych)  
library(GGally)

spotify <- read.csv("dataset.csv", stringsAsFactors = FALSE)

#continuous audio features we plan to analyze
audio_features <- spotify %>%
  select(
    danceability, energy, loudness, speechiness, acousticness,
    instrumentalness, liveness, valence, tempo, duration_ms, popularity
  )

#Summary statistics
summary_stats <- psych::describe(audio_features)
summary_stats

summary(audio_features)

#Correlation matrix
corr_matrix <- cor(audio_features, use = "pairwise.complete.obs")
corr_matrix

#correlation heatmap
GGally::ggcorr(audio_features, label = TRUE, hjust = 0.8, size = 3)

```

```{r}
library(ggplot2)
library(tidyr)
library(dplyr)

audio_features <- spotify %>%
  select(
    danceability, energy, loudness, speechiness, acousticness,
    instrumentalness, liveness, valence, tempo, duration_ms, popularity
  )

#Convert the data to long format for faceted plotting
audio_long <- audio_features %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "value")

# Density plot grid
ggplot(audio_long, aes(x = value)) +
  geom_density(fill = "steelblue", alpha = 0.6) +
  facet_wrap(~ feature, scales = "free", ncol = 3) +
  theme_minimal(base_size = 12) +
  labs(
    title = "Density Plots of Spotify Audio Features",
    x = "Value",
    y = "Density"
  )

```

```{r}
library(dplyr)
library(ggplot2)

audio_features <- spotify %>%
  select(
    danceability, energy, loudness, speechiness, acousticness,
    instrumentalness, liveness, valence, tempo, duration_ms, popularity
  )

#Standardize all features
audio_scaled <- scale(audio_features)

#Perform PCA using prcomp()
pca_result <- prcomp(audio_scaled, center = TRUE, scale. = TRUE)

#View PCA object summary (variance explained)
summary(pca_result)

#loadings
pca_result$rotation

#Extract PCA scores
pca_scores <- as.data.frame(pca_result$x)

#Scree plot
var_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2)

scree_data <- data.frame(
  PC = factor(paste0("PC", 1:length(var_explained)),
              levels = paste0("PC", 1:length(var_explained))),
  Variance = var_explained
)

ggplot(scree_data, aes(x = PC, y = Variance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_line(aes(group = 1), color = "black") +
  geom_point(size = 2, color = "black") +
  theme_minimal(base_size = 12) +
  labs(
    title = "Scree Plot: Proportion of Variance Explained",
    x = "Principal Component",
    y = "Proportion of Variance"
  )

#PCA scatter plot of PC1 vs PC2
ggplot(pca_scores, aes(x = PC1, y = PC2)) +
  geom_point(alpha = 0.3, size = 1, color = "darkred") +
  theme_minimal(base_size = 12) +
  labs(
    title = "PCA Projection: PC1 vs PC2",
    x = "PC1",
    y = "PC2"
  )

```

```{r}
install.packages("plotly")

library(plotly)

# 3D PCA scatter plot (PC1, PC2, PC3)
plot_ly(
  x = pca_scores$PC1,
  y = pca_scores$PC2,
  z = pca_scores$PC3,
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 2, color = pca_scores$PC1, colorscale = "Viridis")
) %>%
  layout(
    title = "3D PCA Scatter Plot",
    scene = list(
      xaxis = list(title = "PC1"),
      yaxis = list(title = "PC2"),
      zaxis = list(title = "PC3")
    )
  )

```

```{r}
library(knitr)
loadings <- pca_result$rotation
loadings
kable(loadings, digits = 3, caption = "PCA Loadings for Audio Features")
```

```{r}
library(ggplot2)

loadings_df <- as.data.frame(pca_result$rotation[,1:2])
loadings_df$feature <- rownames(loadings_df)

ggplot(loadings_df, aes(x = PC1, y = PC2, label = feature)) +
  geom_point(color = "red") +
  geom_text(vjust = -0.5) +
  geom_segment(aes(x = 0, y = 0, xend = PC1, yend = PC2),
               arrow = arrow(length = unit(0.2, "cm"))) +
  theme_minimal() +
  labs(title = "PCA Loadings Plot (PC1 vs PC2)")

```

```{r}
var_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2)

data.frame(
  PC = paste0("PC", 1:length(var_explained)),
  Variance = round(var_explained, 4),
  Cumulative = round(cumsum(var_explained), 4)
)

```

```{r}
ggplot(pca_scores, aes(PC1, PC2, color = spotify$popularity)) +
  geom_point(alpha = 0.4, size = 1) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "PCA Colored by Song Popularity", color = "Popularity")
```

```{r}
ggplot(pca_scores, aes(PC1, PC2, color = spotify$track_genre)) +
  geom_point(alpha = 0.5, size = 1) +
  theme_minimal() +
  labs(title = "PCA Colored by Genre", color = "Genre")
```

```{r}
outliers <- pca_scores %>%
  mutate(id = row_number()) %>%
  filter(abs(PC1) > 4 | abs(PC2) > 4)

outliers
```

```{r}
#Filter dataset to popular songs only
popular_songs <- spotify %>%
  filter(popularity >= 60)

nrow(popular_songs)   #Check how many remain
```

```{r}
pop_features <- popular_songs %>%
  select(
    danceability, energy, loudness, speechiness, acousticness,
    instrumentalness, liveness, valence, tempo, duration_ms, popularity
  )

pop_scaled <- scale(pop_features)
```

```{r}
pca_pop <- prcomp(pop_scaled, center = TRUE, scale. = TRUE)
pca_pop_scores <- as.data.frame(pca_pop$x)
```

```{r}
pca_pop_reduced <- pca_pop_scores[, 1:3]
set.seed(123)

wcss_pop <- sapply(2:10, function(k) {
  kmeans(pca_pop_reduced, centers = k, nstart = 15)$tot.withinss
})

plot(2:10, wcss_pop, type = "b", pch = 19,
     xlab = "Number of Clusters K",
     ylab = "Total Within-Cluster Sum of Squares",
     main = "Elbow Plot for K-means (Popular Songs, PCA Space)")
```

So 4 clusters seems like a reasonable choice.

```{r}
pca_pop_reduced <- pca_pop_scores[, 1:3]

set.seed(123)
k_pop <- kmeans(pca_pop_reduced, centers = 4, nstart = 20)

#Add cluster labels back to data
pca_pop_scores$cluster <- factor(k_pop$cluster)
popular_songs$cluster <- factor(k_pop$cluster)
```

```{r}
library(ggplot2)

ggplot(pca_pop_scores, aes(PC1, PC2, color = cluster)) +
  geom_point(alpha = 0.6, size = 1) +
  theme_minimal(base_size = 12) +
  labs(
    title = "K-means Clusters Among Popular Songs (PCA Space)",
    x = "PC1",
    y = "PC2",
    color = "Cluster"
  )

```

```{r}
set.seed(123)
k_final_pop <- kmeans(pca_pop_reduced, centers = 4, nstart = 30)

popular_songs$cluster <- factor(k_final_pop$cluster)
pca_pop_scores$cluster <- factor(k_final_pop$cluster)
```

```{r}
cluster_feature_means <- popular_songs %>%
  group_by(cluster) %>%
  summarise(across(
    c(danceability, energy, loudness, speechiness, acousticness,
      instrumentalness, liveness, valence, tempo, duration_ms, popularity),
    mean,
    na.rm = TRUE
  ))

cluster_feature_means
```

```{r}
#Distance of each song to the centroid of cluster 2
centroid_pc <- k_pop$centers[2, ]

popular_songs$dist_to_c2 <- rowSums((pca_pop_reduced - centroid_pc)^2)

cluster2_representatives <- popular_songs %>%
  filter(cluster == 2) %>%
  arrange(dist_to_c2) %>%
  head(20)

cluster2_representatives

```

```{r}
cluster2_songs <- popular_songs %>%
  filter(cluster == 2) %>%
  select(track_name, artists, popularity, everything())

head(cluster2_songs, 20)
```
